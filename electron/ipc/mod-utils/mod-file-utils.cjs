// filepath: c:\Users\Saeed\Desktop\ET\Codes\minecraft-core\electron\ipc\mod-utils\mod-file-utils.cjs
const fs = require('fs');
const path = require('path');

/**
 * Disable a mod by renaming it with .disabled extension
 * @param {string} modsDir - The mods directory path
 * @param {string} fileName - The mod filename to disable
 * @returns {Promise<boolean>} - Success status
 */
async function disableMod(modsDir, fileName) {
  try {
    const sourcePath = path.join(modsDir, fileName);
    
    if (!fs.existsSync(sourcePath)) {
      return false;
    }    // Rename the file with .disabled extension
    const targetPath = path.join(modsDir, fileName + '.disabled');
    
    // Check if target already exists
    if (fs.existsSync(targetPath)) {
      return false;
    }

    // Rename the file with .disabled extension
    fs.renameSync(sourcePath, targetPath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Enable a mod by removing the .disabled extension
 * @param {string} modsDir - The mods directory path
 * @param {string} fileName - The mod filename to enable (without .disabled extension)
 * @returns {Promise<boolean>} - Success status
 */
async function enableMod(modsDir, fileName) {
  try {
    const sourcePath = path.join(modsDir, fileName + '.disabled');
    
    if (!fs.existsSync(sourcePath)) {
      return false;
    }

    const targetPath = path.join(modsDir, fileName);
    
    // Check if target already exists
    if (fs.existsSync(targetPath)) {
      return false;
    }

    // Remove the .disabled extension
    fs.renameSync(sourcePath, targetPath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Check if a filename looks like it was generated by a mod API (ugly name)
 * @param {string} fileName - The mod filename to check
 * @returns {boolean} - True if it looks like an API-generated name
 */
function isApiGeneratedName(fileName) {
  const baseName = fileName.replace(/\.jar$/i, '');
  
  // Patterns that indicate API-generated names
  const apiPatterns = [
    /^\[.*\]/, // Starts with [version] like "[1.21.4] Fabric API"
    /\s+\d+\.\d+.*for\s+Fabric/i, // Has "X.Y for Fabric" pattern
    /\s+\d+\.\d+.*for\s+Forge/i, // Has "X.Y for Forge" pattern
    /^.*\s+\d+\.\d+\.\d+\+/, // Has version like "1.2.3+" pattern
    /\s+v?\d+\.\d+\.\d+$/, // Ends with version like "v1.2.3"
  ];
  
  return apiPatterns.some(pattern => pattern.test(baseName));
}

/**
 * Clean up mod filenames by extracting clean names from JAR metadata
 * @param {string} modsDir - The mods directory path
 * @param {function} extractMetadata - Function to extract JAR metadata
 * @returns {Promise<{success: boolean, renamed: string[], errors: string[]}>}
 */
async function cleanupModFilenames(modsDir, extractMetadata) {
  const renamed = [];
  const errors = [];
  
  try {
    if (!fs.existsSync(modsDir)) {
      return { success: true, renamed, errors };
    }
    
    const files = fs.readdirSync(modsDir).filter(file => 
      file.endsWith('.jar') && isApiGeneratedName(file)
    );
    
    for (const fileName of files) {
      try {
        const filePath = path.join(modsDir, fileName);
        const metadata = await extractMetadata(filePath);
        
        if (metadata && metadata.name) {
          // Generate clean filename
          const cleanBase = metadata.name.replace(/[^a-zA-Z0-9_.-]/g, '_');
          const cleanFileName = /\.jar$/i.test(cleanBase) ? cleanBase : `${cleanBase}.jar`;
          
          // Only rename if the clean name is different and doesn't already exist
          if (cleanFileName !== fileName) {
            const cleanFilePath = path.join(modsDir, cleanFileName);
            
            if (!fs.existsSync(cleanFilePath)) {
              fs.renameSync(filePath, cleanFilePath);
              renamed.push(`${fileName} â†’ ${cleanFileName}`);
              
              // Also rename any associated manifest files
              const manifestsDir = path.join(path.dirname(modsDir), 'minecraft-core-manifests');
              const oldManifestPath = path.join(manifestsDir, `${fileName}.json`);
              const newManifestPath = path.join(manifestsDir, `${cleanFileName}.json`);
              
              if (fs.existsSync(oldManifestPath)) {
                try {
                  // Update manifest content to reflect new filename
                  const manifestContent = fs.readFileSync(oldManifestPath, 'utf8');
                  const manifest = JSON.parse(manifestContent);
                  manifest.fileName = cleanFileName;
                  fs.writeFileSync(newManifestPath, JSON.stringify(manifest, null, 2));
                  fs.unlinkSync(oldManifestPath);
                } catch {
                  // If manifest update fails, just move it
                  fs.renameSync(oldManifestPath, newManifestPath);
                }
              }
            }
          }
        }
      } catch (error) {
        errors.push(`Failed to process ${fileName}: ${error.message}`);
      }
    }
    
    return { success: true, renamed, errors };
  } catch (error) {
    errors.push(`Failed to cleanup mod filenames: ${error.message}`);
    return { success: false, renamed, errors };
  }
}

module.exports = {
  disableMod,
  enableMod,
  isApiGeneratedName,
  cleanupModFilenames
};
